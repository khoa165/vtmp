import fs from 'fs';
import path from 'path';
import { promisify } from 'util';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// This type represents the raw metadata extracted from frontmatter
type RawBlogMetadata = Record<string, string> & {
  authors: string; // Comma-separated string
  contributors?: string; // Comma-separated string
  date: string; // Date string
  tags: string; // Comma-separated string
};

const extractMetadata = (text: string): RawBlogMetadata => {
  const metadata: Record<string, string> = {};
  const metaRegExp = RegExp(/^---[\r\n](((?!---).|[\r\n])*)[\r\n]---$/m);
  const rawMetadata = metaRegExp.exec(text);

  if (rawMetadata !== null) {
    const keyValues = rawMetadata[1].split('\n');
    keyValues.forEach((keyValue) => {
      const colonIndex = keyValue.indexOf(':');
      if (colonIndex > 0) {
        const key = keyValue.substring(0, colonIndex).trim();
        let value = keyValue.substring(colonIndex + 1).trim();
        // Remove surrounding quotes if any (common in frontmatter string values)
        if (
          (value.startsWith("'") && value.endsWith("'")) ||
          (value.startsWith('"') && value.endsWith('"'))
        ) {
          value = value.substring(1, value.length - 1);
        }
        metadata[key] = value;
      }
    });
  }
  return metadata as RawBlogMetadata;
};

// This function generates the content for the output metadata.ts file
const buildMetadataFileOutput = (processedMetadataEntries: any[]) => {
  const importStatements = processedMetadataEntries
    .sort((a, b) => a.internalFilepath.localeCompare(b.internalFilepath))
    .map((entry) => {
      // entry.internalFilepath is like './src/blogs/content/vtmp-2023/file.md'
      // Convert to '#vtmp/web-client/' based path for Vite import: '#vtmp/web-client/blogs/content/vtmp-2023/file.md'
      const importPath = entry.internalFilepath.replace(
        './src/',
        '#vtmp/web-client/'
      );
      // Create a unique, valid variable name for the import, e.g., path_2023_04_30_developer_productivity
      const importName = `mdImport_${entry.name.replace(/-/g, '_')}`;
      return `import ${importName} from '${importPath}';`;
    })
    .join('\n');

  const metadataArrayString = processedMetadataEntries
    .sort((a, b) => b.internalFilepath.localeCompare(a.internalFilepath))
    .map((entry) => {
      const importName = `mdImport_${entry.name.replace(/-/g, '_')}`;
      // Construct the object string for each metadata entry
      const entryProperties = Object.entries(entry)
        .map(([key, value]) => {
          if (key === 'filepath') {
            // This 'filepath' is for the final BlogMetadata object
            return `${key}: ${importName}`; // Use the imported variable name
          }
          if (key === 'internalFilepath') {
            // Skip internalFilepath in the final output
            return null;
          }
          // For other properties, use JSON.stringify to correctly format them
          return `${key}: ${JSON.stringify(value)}`;
        })
        .filter((prop) => prop !== null) // Remove null entries (like internalFilepath)
        .join(',\n    ');
      return `  {\n    ${entryProperties}\n  }`;
    })
    .join(',\n');

  return `// This file is auto-generated by scripts/generate-metadata.ts
// Do not edit this file directly.

${importStatements}
import { BlogMetadata } from '#vtmp/web-client/types';

export const allBlogsMetadata: BlogMetadata[] = [
${metadataArrayString}
];
`;
};

const readdir = promisify(fs.readdir);
const readFile = promisify(fs.readFile); // Renamed to avoid conflict with fs.readFile

async function generateMetadata() {
  // Renamed for clarity
  try {
    const contentDirectoryRoot = path.join(
      __dirname,
      '../web-client/src/blogs/content'
    );

    // Recursive read to get all files in all subdirectories
    const allFileAndDirPaths = (
      await readdir(contentDirectoryRoot, { recursive: true })
    ).map(String);

    const mdFileRelativePaths = allFileAndDirPaths.filter((p: string) =>
      p.endsWith('.md')
    );

    const fileDataPromises = mdFileRelativePaths.map(async (relativeMdPath) => {
      const fullFilePath = path.join(contentDirectoryRoot, relativeMdPath);
      return {
        content: await readFile(fullFilePath, 'utf-8'),
        relativeMdPath, // e.g., 'vtmp-2023/2023-04-30-file.md' or 'another-folder/file.md'
      };
    });

    const contentsWithRelativePaths = await Promise.all(fileDataPromises);

    const processedMetadata = contentsWithRelativePaths.map(
      ({ content, relativeMdPath }) => {
        const frontmatter = extractMetadata(content);

        // Construct the name from the filename part of relativeMdPath
        // e.g., 'vtmp-2023/2023-04-30-file.md' -> '2023-04-30-file'
        const fileNameWithoutExtension = path.basename(relativeMdPath, '.md');

        // This path is used internally to generate the import statement
        // It needs to be relative to the project root, starting with './src/...'
        const internalFilepathForImport =
          `./src/blogs/content/${relativeMdPath}`.replace(/\\/g, '/');

        return {
          ...frontmatter, // Spread raw string properties first
          name: fileNameWithoutExtension,
          // Process raw frontmatter strings into structured data for the final BlogMetadata type
          date: frontmatter.date ? new Date(frontmatter.date) : new Date(),
          authors: frontmatter.authors
            ? frontmatter.authors.split(',').map((s) => s.trim())
            : [],
          contributors: frontmatter.contributors
            ? frontmatter.contributors.split(',').map((s) => s.trim())
            : [],
          tags: frontmatter.tags
            ? frontmatter.tags.split(',').map((s) => s.trim())
            : [],
          // 'filepath' will be the imported module name, set in buildMetadataFileOutput
          // Add internalFilepath to pass it to buildMetadataFileOutput for generating the import
          internalFilepath: internalFilepathForImport,
          filepath: '', // Placeholder, will be replaced by the import variable in buildMetadataFileOutput
        };
      }
    );

    // Write only the metadata.ts file
    fs.writeFileSync(
      path.join(__dirname, '../web-client/src/blogs/metadata/metadata.ts'),
      buildMetadataFileOutput(processedMetadata)
    );

    console.log(
      'Successfully generated: web-client/src/blogs/metadata/metadata.ts'
    );
  } catch (err) {
    console.error('Unable to finish generating metadata:', err);
    process.exit(1); // Exit with error code if script fails
  }
}

generateMetadata();
